# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rexml` gem.
# Please instead update this file by running `bin/tapioca gem rexml`.


# source://rexml//lib/rexml/encoding.rb#4
module REXML::Encoding
  # source://rexml//lib/rexml/encoding.rb#29
  def decode(string); end

  # source://rexml//lib/rexml/encoding.rb#25
  def encode(string); end

  # ID ---> Encoding name
  #
  # source://rexml//lib/rexml/encoding.rb#6
  def encoding; end

  # source://rexml//lib/rexml/encoding.rb#7
  def encoding=(encoding); end

  private

  # source://rexml//lib/rexml/encoding.rb#34
  def find_encoding(name); end
end

# A Source that wraps an IO.  See the Source class for method
# documentation
#
# source://rexml//lib/rexml/source.rb#140
class REXML::IOSource < ::REXML::Source
  # block_size has been deprecated
  #
  # @return [IOSource] a new instance of IOSource
  #
  # source://rexml//lib/rexml/source.rb#144
  def initialize(arg, block_size = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#217
  def current_line; end

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/source.rb#212
  def empty?; end

  # source://rexml//lib/rexml/source.rb#189
  def ensure_buffer; end

  # Note: When specifying a string for 'pattern', it must not include '>' except in the following formats:
  # - ">"
  # - "XXX>" (X is any string excluding '>')
  #
  # source://rexml//lib/rexml/source.rb#196
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#165
  def read(term = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#175
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#259
  def encoding_updated; end

  # source://rexml//lib/rexml/source.rb#239
  def readline(term = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/parseexception.rb#3
class REXML::ParseException < ::RuntimeError
  # @return [ParseException] a new instance of ParseException
  #
  # source://rexml//lib/rexml/parseexception.rb#6
  def initialize(message, source = T.unsafe(nil), parser = T.unsafe(nil), exception = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parseexception.rb#49
  def context; end

  # Returns the value of attribute continued_exception.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception; end

  # Sets the attribute continued_exception
  #
  # @param value the value to set the attribute continued_exception to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#44
  def line; end

  # Returns the value of attribute parser.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser; end

  # Sets the attribute parser
  #
  # @param value the value to set the attribute parser to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def parser=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#39
  def position; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://rexml//lib/rexml/parseexception.rb#4
  def source=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#13
  def to_s; end
end

# = Using the Pull Parser
# <em>This API is experimental, and subject to change.</em>
#  parser = PullParser.new( "<a>text<b att='val'/>txet</a>" )
#  while parser.has_next?
#    res = parser.next
#    puts res[1]['att'] if res.start_tag? and res[0] == 'b'
#  end
# See the PullEvent class for information on the content of the results.
# The data is identical to the arguments passed for the various events to
# the StreamListener API.
#
# Notice that:
#  parser = PullParser.new( "<a>BAD DOCUMENT" )
#  while parser.has_next?
#    res = parser.next
#    raise res[1] if res.error?
#  end
#
# Nat Price gave me some good ideas for the API.
#
# source://rexml//lib/rexml/parsers/baseparser.rb#29
class REXML::Parsers::BaseParser
  include ::REXML::Parsers::BaseParser::Private

  # @return [BaseParser] a new instance of BaseParser
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#128
  def initialize(source); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#133
  def add_listener(listener); end

  # Returns true if there are no more events
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#159
  def empty?; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#446
  def entity(reference, entities); end

  # Returns true if there are more events.  Synonymous with !empty?
  #
  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#164
  def has_next?; end

  # Escapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#457
  def normalize(input, entities = T.unsafe(nil), entity_filter = T.unsafe(nil)); end

  # Peek at the +depth+ event in the stack.  The first element on the stack
  # is at depth 0.  If +depth+ is -1, will parse to the end of the input
  # stream and return the last event, which is always :end_document.
  # Be aware that this causes the stream to be parsed up to the +depth+
  # event, so you can effectively pre-parse the entire document (pull the
  # entire thing into memory) using this method.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#180
  def peek(depth = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#149
  def position; end

  # Returns the next event.  This is a +PullEvent+ object.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#195
  def pull; end

  # Returns the value of attribute source.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#137
  def source; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#139
  def stream=(source); end

  # Unescapes all possible entities
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#473
  def unnormalize(string, entities = T.unsafe(nil), filter = T.unsafe(nil)); end

  # Push an event back on the head of the stream.  This method
  # has (theoretically) infinite depth.
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#170
  def unshift(token); end

  private

  # @return [Boolean]
  #
  # source://rexml//lib/rexml/parsers/baseparser.rb#502
  def need_source_encoding_update?(xml_declaration_encoding); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#613
  def parse_attributes(prefixes, curr_ns); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#521
  def parse_id(base_error_message, accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#549
  def parse_id_invalid_details(accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#508
  def parse_name(base_error_message); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#587
  def process_instruction(start_position); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#203
  def pull_event; end
end

# source://rexml//lib/rexml/parsers/baseparser.rb#102
REXML::Parsers::BaseParser::EXTERNAL_ID_PUBLIC = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#103
REXML::Parsers::BaseParser::EXTERNAL_ID_SYSTEM = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#104
REXML::Parsers::BaseParser::PUBLIC_ID = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#115
module REXML::Parsers::BaseParser::Private; end

# source://rexml//lib/rexml/parsers/baseparser.rb#119
REXML::Parsers::BaseParser::Private::ATTLISTDECL_END = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#118
REXML::Parsers::BaseParser::Private::CLOSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#123
REXML::Parsers::BaseParser::Private::ENTITYDECL_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#121
REXML::Parsers::BaseParser::Private::GEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#116
REXML::Parsers::BaseParser::Private::INSTRUCTION_END = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#120
REXML::Parsers::BaseParser::Private::NAME_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#122
REXML::Parsers::BaseParser::Private::PEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#117
REXML::Parsers::BaseParser::Private::TAG_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#38
REXML::Parsers::BaseParser::QNAME = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#37
REXML::Parsers::BaseParser::QNAME_STR = T.let(T.unsafe(nil), String)

# A Source can be searched for patterns, and wraps buffers and other
# objects and provides consumption of text
#
# source://rexml//lib/rexml/source.rb#31
class REXML::Source
  include ::REXML::Encoding

  # Constructor
  # value, overriding all encoding detection
  #
  # @param arg must be a String, and should be a valid XML document
  # @param encoding if non-null, sets the encoding of the source to this
  # @return [Source] a new instance of Source
  #
  # source://rexml//lib/rexml/source.rb#41
  def initialize(arg, encoding = T.unsafe(nil)); end

  # The current buffer (what we're going to read next)
  #
  # source://rexml//lib/rexml/source.rb#53
  def buffer; end

  # source://rexml//lib/rexml/source.rb#57
  def buffer_encoding=(encoding); end

  # @return the current line in the source
  #
  # source://rexml//lib/rexml/source.rb#100
  def current_line; end

  # @return [Boolean] true if the Source is exhausted
  #
  # source://rexml//lib/rexml/source.rb#95
  def empty?; end

  # Returns the value of attribute encoding.
  #
  # source://rexml//lib/rexml/source.rb#35
  def encoding; end

  # Inherited from Encoding
  # Overridden to support optimized en/decoding
  #
  # source://rexml//lib/rexml/source.rb#63
  def encoding=(enc); end

  # source://rexml//lib/rexml/source.rb#75
  def ensure_buffer; end

  # The line number of the last consumed text
  #
  # source://rexml//lib/rexml/source.rb#34
  def line; end

  # source://rexml//lib/rexml/source.rb#78
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#86
  def position; end

  # source://rexml//lib/rexml/source.rb#90
  def position=(pos); end

  # source://rexml//lib/rexml/source.rb#68
  def read(term = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#71
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#109
  def detect_encoding; end

  # source://rexml//lib/rexml/source.rb#127
  def encoding_updated; end
end

# source://rexml//lib/rexml/undefinednamespaceexception.rb#4
class REXML::UndefinedNamespaceException < ::REXML::ParseException
  # @return [UndefinedNamespaceException] a new instance of UndefinedNamespaceException
  #
  # source://rexml//lib/rexml/undefinednamespaceexception.rb#5
  def initialize(prefix, source, parser); end
end
